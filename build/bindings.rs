/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod gli {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type byte = root::glm::uint8;
        pub type extent1d = root::glm::ivec1;
        pub type extent2d = root::glm::ivec2;
        pub type extent3d = root::glm::ivec3;
        pub const target_TARGET_1D: root::gli::target = 0;
        pub const target_TARGET_FIRST: root::gli::target = 0;
        pub const target_TARGET_1D_ARRAY: root::gli::target = 1;
        pub const target_TARGET_2D: root::gli::target = 2;
        pub const target_TARGET_2D_ARRAY: root::gli::target = 3;
        pub const target_TARGET_3D: root::gli::target = 4;
        pub const target_TARGET_RECT: root::gli::target = 5;
        pub const target_TARGET_RECT_ARRAY: root::gli::target = 6;
        pub const target_TARGET_CUBE: root::gli::target = 7;
        pub const target_TARGET_CUBE_ARRAY: root::gli::target = 8;
        pub const target_TARGET_LAST: root::gli::target = 8;
        #[doc = " Texture target: type/shape of the texture storage_linear"]
        pub type target = u32;
        pub const format_FORMAT_UNDEFINED: root::gli::format = 0;
        pub const format_FORMAT_RG4_UNORM_PACK8: root::gli::format = 1;
        pub const format_FORMAT_FIRST: root::gli::format = 1;
        pub const format_FORMAT_RGBA4_UNORM_PACK16: root::gli::format = 2;
        pub const format_FORMAT_BGRA4_UNORM_PACK16: root::gli::format = 3;
        pub const format_FORMAT_R5G6B5_UNORM_PACK16: root::gli::format = 4;
        pub const format_FORMAT_B5G6R5_UNORM_PACK16: root::gli::format = 5;
        pub const format_FORMAT_RGB5A1_UNORM_PACK16: root::gli::format = 6;
        pub const format_FORMAT_BGR5A1_UNORM_PACK16: root::gli::format = 7;
        pub const format_FORMAT_A1RGB5_UNORM_PACK16: root::gli::format = 8;
        pub const format_FORMAT_R8_UNORM_PACK8: root::gli::format = 9;
        pub const format_FORMAT_R8_SNORM_PACK8: root::gli::format = 10;
        pub const format_FORMAT_R8_USCALED_PACK8: root::gli::format = 11;
        pub const format_FORMAT_R8_SSCALED_PACK8: root::gli::format = 12;
        pub const format_FORMAT_R8_UINT_PACK8: root::gli::format = 13;
        pub const format_FORMAT_R8_SINT_PACK8: root::gli::format = 14;
        pub const format_FORMAT_R8_SRGB_PACK8: root::gli::format = 15;
        pub const format_FORMAT_RG8_UNORM_PACK8: root::gli::format = 16;
        pub const format_FORMAT_RG8_SNORM_PACK8: root::gli::format = 17;
        pub const format_FORMAT_RG8_USCALED_PACK8: root::gli::format = 18;
        pub const format_FORMAT_RG8_SSCALED_PACK8: root::gli::format = 19;
        pub const format_FORMAT_RG8_UINT_PACK8: root::gli::format = 20;
        pub const format_FORMAT_RG8_SINT_PACK8: root::gli::format = 21;
        pub const format_FORMAT_RG8_SRGB_PACK8: root::gli::format = 22;
        pub const format_FORMAT_RGB8_UNORM_PACK8: root::gli::format = 23;
        pub const format_FORMAT_RGB8_SNORM_PACK8: root::gli::format = 24;
        pub const format_FORMAT_RGB8_USCALED_PACK8: root::gli::format = 25;
        pub const format_FORMAT_RGB8_SSCALED_PACK8: root::gli::format = 26;
        pub const format_FORMAT_RGB8_UINT_PACK8: root::gli::format = 27;
        pub const format_FORMAT_RGB8_SINT_PACK8: root::gli::format = 28;
        pub const format_FORMAT_RGB8_SRGB_PACK8: root::gli::format = 29;
        pub const format_FORMAT_BGR8_UNORM_PACK8: root::gli::format = 30;
        pub const format_FORMAT_BGR8_SNORM_PACK8: root::gli::format = 31;
        pub const format_FORMAT_BGR8_USCALED_PACK8: root::gli::format = 32;
        pub const format_FORMAT_BGR8_SSCALED_PACK8: root::gli::format = 33;
        pub const format_FORMAT_BGR8_UINT_PACK8: root::gli::format = 34;
        pub const format_FORMAT_BGR8_SINT_PACK8: root::gli::format = 35;
        pub const format_FORMAT_BGR8_SRGB_PACK8: root::gli::format = 36;
        pub const format_FORMAT_RGBA8_UNORM_PACK8: root::gli::format = 37;
        pub const format_FORMAT_RGBA8_SNORM_PACK8: root::gli::format = 38;
        pub const format_FORMAT_RGBA8_USCALED_PACK8: root::gli::format = 39;
        pub const format_FORMAT_RGBA8_SSCALED_PACK8: root::gli::format = 40;
        pub const format_FORMAT_RGBA8_UINT_PACK8: root::gli::format = 41;
        pub const format_FORMAT_RGBA8_SINT_PACK8: root::gli::format = 42;
        pub const format_FORMAT_RGBA8_SRGB_PACK8: root::gli::format = 43;
        pub const format_FORMAT_BGRA8_UNORM_PACK8: root::gli::format = 44;
        pub const format_FORMAT_BGRA8_SNORM_PACK8: root::gli::format = 45;
        pub const format_FORMAT_BGRA8_USCALED_PACK8: root::gli::format = 46;
        pub const format_FORMAT_BGRA8_SSCALED_PACK8: root::gli::format = 47;
        pub const format_FORMAT_BGRA8_UINT_PACK8: root::gli::format = 48;
        pub const format_FORMAT_BGRA8_SINT_PACK8: root::gli::format = 49;
        pub const format_FORMAT_BGRA8_SRGB_PACK8: root::gli::format = 50;
        pub const format_FORMAT_RGBA8_UNORM_PACK32: root::gli::format = 51;
        pub const format_FORMAT_RGBA8_SNORM_PACK32: root::gli::format = 52;
        pub const format_FORMAT_RGBA8_USCALED_PACK32: root::gli::format = 53;
        pub const format_FORMAT_RGBA8_SSCALED_PACK32: root::gli::format = 54;
        pub const format_FORMAT_RGBA8_UINT_PACK32: root::gli::format = 55;
        pub const format_FORMAT_RGBA8_SINT_PACK32: root::gli::format = 56;
        pub const format_FORMAT_RGBA8_SRGB_PACK32: root::gli::format = 57;
        pub const format_FORMAT_RGB10A2_UNORM_PACK32: root::gli::format = 58;
        pub const format_FORMAT_RGB10A2_SNORM_PACK32: root::gli::format = 59;
        pub const format_FORMAT_RGB10A2_USCALED_PACK32: root::gli::format = 60;
        pub const format_FORMAT_RGB10A2_SSCALED_PACK32: root::gli::format = 61;
        pub const format_FORMAT_RGB10A2_UINT_PACK32: root::gli::format = 62;
        pub const format_FORMAT_RGB10A2_SINT_PACK32: root::gli::format = 63;
        pub const format_FORMAT_BGR10A2_UNORM_PACK32: root::gli::format = 64;
        pub const format_FORMAT_BGR10A2_SNORM_PACK32: root::gli::format = 65;
        pub const format_FORMAT_BGR10A2_USCALED_PACK32: root::gli::format = 66;
        pub const format_FORMAT_BGR10A2_SSCALED_PACK32: root::gli::format = 67;
        pub const format_FORMAT_BGR10A2_UINT_PACK32: root::gli::format = 68;
        pub const format_FORMAT_BGR10A2_SINT_PACK32: root::gli::format = 69;
        pub const format_FORMAT_R16_UNORM_PACK16: root::gli::format = 70;
        pub const format_FORMAT_R16_SNORM_PACK16: root::gli::format = 71;
        pub const format_FORMAT_R16_USCALED_PACK16: root::gli::format = 72;
        pub const format_FORMAT_R16_SSCALED_PACK16: root::gli::format = 73;
        pub const format_FORMAT_R16_UINT_PACK16: root::gli::format = 74;
        pub const format_FORMAT_R16_SINT_PACK16: root::gli::format = 75;
        pub const format_FORMAT_R16_SFLOAT_PACK16: root::gli::format = 76;
        pub const format_FORMAT_RG16_UNORM_PACK16: root::gli::format = 77;
        pub const format_FORMAT_RG16_SNORM_PACK16: root::gli::format = 78;
        pub const format_FORMAT_RG16_USCALED_PACK16: root::gli::format = 79;
        pub const format_FORMAT_RG16_SSCALED_PACK16: root::gli::format = 80;
        pub const format_FORMAT_RG16_UINT_PACK16: root::gli::format = 81;
        pub const format_FORMAT_RG16_SINT_PACK16: root::gli::format = 82;
        pub const format_FORMAT_RG16_SFLOAT_PACK16: root::gli::format = 83;
        pub const format_FORMAT_RGB16_UNORM_PACK16: root::gli::format = 84;
        pub const format_FORMAT_RGB16_SNORM_PACK16: root::gli::format = 85;
        pub const format_FORMAT_RGB16_USCALED_PACK16: root::gli::format = 86;
        pub const format_FORMAT_RGB16_SSCALED_PACK16: root::gli::format = 87;
        pub const format_FORMAT_RGB16_UINT_PACK16: root::gli::format = 88;
        pub const format_FORMAT_RGB16_SINT_PACK16: root::gli::format = 89;
        pub const format_FORMAT_RGB16_SFLOAT_PACK16: root::gli::format = 90;
        pub const format_FORMAT_RGBA16_UNORM_PACK16: root::gli::format = 91;
        pub const format_FORMAT_RGBA16_SNORM_PACK16: root::gli::format = 92;
        pub const format_FORMAT_RGBA16_USCALED_PACK16: root::gli::format = 93;
        pub const format_FORMAT_RGBA16_SSCALED_PACK16: root::gli::format = 94;
        pub const format_FORMAT_RGBA16_UINT_PACK16: root::gli::format = 95;
        pub const format_FORMAT_RGBA16_SINT_PACK16: root::gli::format = 96;
        pub const format_FORMAT_RGBA16_SFLOAT_PACK16: root::gli::format = 97;
        pub const format_FORMAT_R32_UINT_PACK32: root::gli::format = 98;
        pub const format_FORMAT_R32_SINT_PACK32: root::gli::format = 99;
        pub const format_FORMAT_R32_SFLOAT_PACK32: root::gli::format = 100;
        pub const format_FORMAT_RG32_UINT_PACK32: root::gli::format = 101;
        pub const format_FORMAT_RG32_SINT_PACK32: root::gli::format = 102;
        pub const format_FORMAT_RG32_SFLOAT_PACK32: root::gli::format = 103;
        pub const format_FORMAT_RGB32_UINT_PACK32: root::gli::format = 104;
        pub const format_FORMAT_RGB32_SINT_PACK32: root::gli::format = 105;
        pub const format_FORMAT_RGB32_SFLOAT_PACK32: root::gli::format = 106;
        pub const format_FORMAT_RGBA32_UINT_PACK32: root::gli::format = 107;
        pub const format_FORMAT_RGBA32_SINT_PACK32: root::gli::format = 108;
        pub const format_FORMAT_RGBA32_SFLOAT_PACK32: root::gli::format = 109;
        pub const format_FORMAT_R64_UINT_PACK64: root::gli::format = 110;
        pub const format_FORMAT_R64_SINT_PACK64: root::gli::format = 111;
        pub const format_FORMAT_R64_SFLOAT_PACK64: root::gli::format = 112;
        pub const format_FORMAT_RG64_UINT_PACK64: root::gli::format = 113;
        pub const format_FORMAT_RG64_SINT_PACK64: root::gli::format = 114;
        pub const format_FORMAT_RG64_SFLOAT_PACK64: root::gli::format = 115;
        pub const format_FORMAT_RGB64_UINT_PACK64: root::gli::format = 116;
        pub const format_FORMAT_RGB64_SINT_PACK64: root::gli::format = 117;
        pub const format_FORMAT_RGB64_SFLOAT_PACK64: root::gli::format = 118;
        pub const format_FORMAT_RGBA64_UINT_PACK64: root::gli::format = 119;
        pub const format_FORMAT_RGBA64_SINT_PACK64: root::gli::format = 120;
        pub const format_FORMAT_RGBA64_SFLOAT_PACK64: root::gli::format = 121;
        pub const format_FORMAT_RG11B10_UFLOAT_PACK32: root::gli::format = 122;
        pub const format_FORMAT_RGB9E5_UFLOAT_PACK32: root::gli::format = 123;
        pub const format_FORMAT_D16_UNORM_PACK16: root::gli::format = 124;
        pub const format_FORMAT_D24_UNORM_PACK32: root::gli::format = 125;
        pub const format_FORMAT_D32_SFLOAT_PACK32: root::gli::format = 126;
        pub const format_FORMAT_S8_UINT_PACK8: root::gli::format = 127;
        pub const format_FORMAT_D16_UNORM_S8_UINT_PACK32: root::gli::format = 128;
        pub const format_FORMAT_D24_UNORM_S8_UINT_PACK32: root::gli::format = 129;
        pub const format_FORMAT_D32_SFLOAT_S8_UINT_PACK64: root::gli::format = 130;
        pub const format_FORMAT_RGB_DXT1_UNORM_BLOCK8: root::gli::format = 131;
        pub const format_FORMAT_RGB_DXT1_SRGB_BLOCK8: root::gli::format = 132;
        pub const format_FORMAT_RGBA_DXT1_UNORM_BLOCK8: root::gli::format = 133;
        pub const format_FORMAT_RGBA_DXT1_SRGB_BLOCK8: root::gli::format = 134;
        pub const format_FORMAT_RGBA_DXT3_UNORM_BLOCK16: root::gli::format = 135;
        pub const format_FORMAT_RGBA_DXT3_SRGB_BLOCK16: root::gli::format = 136;
        pub const format_FORMAT_RGBA_DXT5_UNORM_BLOCK16: root::gli::format = 137;
        pub const format_FORMAT_RGBA_DXT5_SRGB_BLOCK16: root::gli::format = 138;
        pub const format_FORMAT_R_ATI1N_UNORM_BLOCK8: root::gli::format = 139;
        pub const format_FORMAT_R_ATI1N_SNORM_BLOCK8: root::gli::format = 140;
        pub const format_FORMAT_RG_ATI2N_UNORM_BLOCK16: root::gli::format = 141;
        pub const format_FORMAT_RG_ATI2N_SNORM_BLOCK16: root::gli::format = 142;
        pub const format_FORMAT_RGB_BP_UFLOAT_BLOCK16: root::gli::format = 143;
        pub const format_FORMAT_RGB_BP_SFLOAT_BLOCK16: root::gli::format = 144;
        pub const format_FORMAT_RGBA_BP_UNORM_BLOCK16: root::gli::format = 145;
        pub const format_FORMAT_RGBA_BP_SRGB_BLOCK16: root::gli::format = 146;
        pub const format_FORMAT_RGB_ETC2_UNORM_BLOCK8: root::gli::format = 147;
        pub const format_FORMAT_RGB_ETC2_SRGB_BLOCK8: root::gli::format = 148;
        pub const format_FORMAT_RGBA_ETC2_UNORM_BLOCK8: root::gli::format = 149;
        pub const format_FORMAT_RGBA_ETC2_SRGB_BLOCK8: root::gli::format = 150;
        pub const format_FORMAT_RGBA_ETC2_UNORM_BLOCK16: root::gli::format = 151;
        pub const format_FORMAT_RGBA_ETC2_SRGB_BLOCK16: root::gli::format = 152;
        pub const format_FORMAT_R_EAC_UNORM_BLOCK8: root::gli::format = 153;
        pub const format_FORMAT_R_EAC_SNORM_BLOCK8: root::gli::format = 154;
        pub const format_FORMAT_RG_EAC_UNORM_BLOCK16: root::gli::format = 155;
        pub const format_FORMAT_RG_EAC_SNORM_BLOCK16: root::gli::format = 156;
        pub const format_FORMAT_RGBA_ASTC_4X4_UNORM_BLOCK16: root::gli::format = 157;
        pub const format_FORMAT_RGBA_ASTC_4X4_SRGB_BLOCK16: root::gli::format = 158;
        pub const format_FORMAT_RGBA_ASTC_5X4_UNORM_BLOCK16: root::gli::format = 159;
        pub const format_FORMAT_RGBA_ASTC_5X4_SRGB_BLOCK16: root::gli::format = 160;
        pub const format_FORMAT_RGBA_ASTC_5X5_UNORM_BLOCK16: root::gli::format = 161;
        pub const format_FORMAT_RGBA_ASTC_5X5_SRGB_BLOCK16: root::gli::format = 162;
        pub const format_FORMAT_RGBA_ASTC_6X5_UNORM_BLOCK16: root::gli::format = 163;
        pub const format_FORMAT_RGBA_ASTC_6X5_SRGB_BLOCK16: root::gli::format = 164;
        pub const format_FORMAT_RGBA_ASTC_6X6_UNORM_BLOCK16: root::gli::format = 165;
        pub const format_FORMAT_RGBA_ASTC_6X6_SRGB_BLOCK16: root::gli::format = 166;
        pub const format_FORMAT_RGBA_ASTC_8X5_UNORM_BLOCK16: root::gli::format = 167;
        pub const format_FORMAT_RGBA_ASTC_8X5_SRGB_BLOCK16: root::gli::format = 168;
        pub const format_FORMAT_RGBA_ASTC_8X6_UNORM_BLOCK16: root::gli::format = 169;
        pub const format_FORMAT_RGBA_ASTC_8X6_SRGB_BLOCK16: root::gli::format = 170;
        pub const format_FORMAT_RGBA_ASTC_8X8_UNORM_BLOCK16: root::gli::format = 171;
        pub const format_FORMAT_RGBA_ASTC_8X8_SRGB_BLOCK16: root::gli::format = 172;
        pub const format_FORMAT_RGBA_ASTC_10X5_UNORM_BLOCK16: root::gli::format = 173;
        pub const format_FORMAT_RGBA_ASTC_10X5_SRGB_BLOCK16: root::gli::format = 174;
        pub const format_FORMAT_RGBA_ASTC_10X6_UNORM_BLOCK16: root::gli::format = 175;
        pub const format_FORMAT_RGBA_ASTC_10X6_SRGB_BLOCK16: root::gli::format = 176;
        pub const format_FORMAT_RGBA_ASTC_10X8_UNORM_BLOCK16: root::gli::format = 177;
        pub const format_FORMAT_RGBA_ASTC_10X8_SRGB_BLOCK16: root::gli::format = 178;
        pub const format_FORMAT_RGBA_ASTC_10X10_UNORM_BLOCK16: root::gli::format = 179;
        pub const format_FORMAT_RGBA_ASTC_10X10_SRGB_BLOCK16: root::gli::format = 180;
        pub const format_FORMAT_RGBA_ASTC_12X10_UNORM_BLOCK16: root::gli::format = 181;
        pub const format_FORMAT_RGBA_ASTC_12X10_SRGB_BLOCK16: root::gli::format = 182;
        pub const format_FORMAT_RGBA_ASTC_12X12_UNORM_BLOCK16: root::gli::format = 183;
        pub const format_FORMAT_RGBA_ASTC_12X12_SRGB_BLOCK16: root::gli::format = 184;
        pub const format_FORMAT_RGB_PVRTC1_8X8_UNORM_BLOCK32: root::gli::format = 185;
        pub const format_FORMAT_RGB_PVRTC1_8X8_SRGB_BLOCK32: root::gli::format = 186;
        pub const format_FORMAT_RGB_PVRTC1_16X8_UNORM_BLOCK32: root::gli::format = 187;
        pub const format_FORMAT_RGB_PVRTC1_16X8_SRGB_BLOCK32: root::gli::format = 188;
        pub const format_FORMAT_RGBA_PVRTC1_8X8_UNORM_BLOCK32: root::gli::format = 189;
        pub const format_FORMAT_RGBA_PVRTC1_8X8_SRGB_BLOCK32: root::gli::format = 190;
        pub const format_FORMAT_RGBA_PVRTC1_16X8_UNORM_BLOCK32: root::gli::format = 191;
        pub const format_FORMAT_RGBA_PVRTC1_16X8_SRGB_BLOCK32: root::gli::format = 192;
        pub const format_FORMAT_RGBA_PVRTC2_4X4_UNORM_BLOCK8: root::gli::format = 193;
        pub const format_FORMAT_RGBA_PVRTC2_4X4_SRGB_BLOCK8: root::gli::format = 194;
        pub const format_FORMAT_RGBA_PVRTC2_8X4_UNORM_BLOCK8: root::gli::format = 195;
        pub const format_FORMAT_RGBA_PVRTC2_8X4_SRGB_BLOCK8: root::gli::format = 196;
        pub const format_FORMAT_RGB_ETC_UNORM_BLOCK8: root::gli::format = 197;
        pub const format_FORMAT_RGB_ATC_UNORM_BLOCK8: root::gli::format = 198;
        pub const format_FORMAT_RGBA_ATCA_UNORM_BLOCK16: root::gli::format = 199;
        pub const format_FORMAT_RGBA_ATCI_UNORM_BLOCK16: root::gli::format = 200;
        pub const format_FORMAT_L8_UNORM_PACK8: root::gli::format = 201;
        pub const format_FORMAT_A8_UNORM_PACK8: root::gli::format = 202;
        pub const format_FORMAT_LA8_UNORM_PACK8: root::gli::format = 203;
        pub const format_FORMAT_L16_UNORM_PACK16: root::gli::format = 204;
        pub const format_FORMAT_A16_UNORM_PACK16: root::gli::format = 205;
        pub const format_FORMAT_LA16_UNORM_PACK16: root::gli::format = 206;
        pub const format_FORMAT_BGR8_UNORM_PACK32: root::gli::format = 207;
        pub const format_FORMAT_BGR8_SRGB_PACK32: root::gli::format = 208;
        pub const format_FORMAT_RG3B2_UNORM_PACK8: root::gli::format = 209;
        pub const format_FORMAT_LAST: root::gli::format = 209;
        #[doc = " Texture data format"]
        pub type format = u32;
        pub const swizzle_SWIZZLE_RED: root::gli::swizzle = 0;
        pub const swizzle_SWIZZLE_FIRST: root::gli::swizzle = 0;
        pub const swizzle_SWIZZLE_CHANNEL_FIRST: root::gli::swizzle = 0;
        pub const swizzle_SWIZZLE_GREEN: root::gli::swizzle = 1;
        pub const swizzle_SWIZZLE_BLUE: root::gli::swizzle = 2;
        pub const swizzle_SWIZZLE_ALPHA: root::gli::swizzle = 3;
        pub const swizzle_SWIZZLE_CHANNEL_LAST: root::gli::swizzle = 3;
        pub const swizzle_SWIZZLE_ZERO: root::gli::swizzle = 4;
        pub const swizzle_SWIZZLE_ONE: root::gli::swizzle = 5;
        pub const swizzle_SWIZZLE_LAST: root::gli::swizzle = 5;
        #[doc = " Represent the source of a channel"]
        pub type swizzle = u32;
        pub type swizzles = [u32; 4usize];
        extern "C" {
            #[doc = " Evaluate whether a format is compressed"]
            pub fn is_compressed(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether a format is compressed with an S3TC algorithm."]
            pub fn is_s3tc_compressed(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether a format stores sRGB color space values"]
            pub fn is_srgb(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether a format is unsigned"]
            pub fn is_unsigned(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether a format is signed"]
            pub fn is_signed(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is an integer format"]
            pub fn is_integer(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is a signed integer format"]
            pub fn is_signed_integer(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is an unsigned integer format"]
            pub fn is_unsigned_integer(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is an float format"]
            pub fn is_float(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is normalized"]
            pub fn is_normalized(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is an unsigned normalized format"]
            pub fn is_unorm(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is a signed normalized format"]
            pub fn is_snorm(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is packed"]
            pub fn is_packed(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format is a depth format"]
            pub fn is_depth(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format has a stencil component"]
            pub fn is_stencil(Format: root::gli::format) -> bool;
        }
        extern "C" {
            #[doc = " Evaluate whether the format has depth and stencil components"]
            pub fn is_depth_stencil(Format: root::gli::format) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct storage_linear {
            pub Layers: root::gli::storage_linear_size_type,
            pub Faces: root::gli::storage_linear_size_type,
            pub Levels: root::gli::storage_linear_size_type,
            pub BlockSize: root::gli::storage_linear_size_type,
            pub BlockCount: root::gli::storage_linear_extent_type,
            pub BlockExtent: root::gli::storage_linear_extent_type,
            pub Extent: root::gli::storage_linear_extent_type,
            pub Data: [u64; 3usize],
        }
        pub type storage_linear_extent_type = root::gli::extent3d;
        pub type storage_linear_size_type = usize;
        pub use self::super::super::root::gli::format as storage_linear_format_type;
        pub type storage_linear_data_type = root::gli::byte;
        extern "C" {
            #[link_name = "\u{1}empty"]
            pub fn storage_linear_empty(this: *const root::gli::storage_linear) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}size"]
            pub fn storage_linear_size(
                this: *const root::gli::storage_linear,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}layers"]
            pub fn storage_linear_layers(
                this: *const root::gli::storage_linear,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}levels"]
            pub fn storage_linear_levels(
                this: *const root::gli::storage_linear,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}faces"]
            pub fn storage_linear_faces(
                this: *const root::gli::storage_linear,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}block_size"]
            pub fn storage_linear_block_size(
                this: *const root::gli::storage_linear,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}block_extent"]
            pub fn storage_linear_block_extent(
                this: *const root::gli::storage_linear,
            ) -> root::gli::storage_linear_extent_type;
        }
        extern "C" {
            #[link_name = "\u{1}block_count"]
            pub fn storage_linear_block_count(
                this: *const root::gli::storage_linear,
                Level: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_extent_type;
        }
        extern "C" {
            #[link_name = "\u{1}extent"]
            pub fn storage_linear_extent(
                this: *const root::gli::storage_linear,
                Level: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_extent_type;
        }
        extern "C" {
            #[link_name = "\u{1}data"]
            pub fn storage_linear_data(
                this: *mut root::gli::storage_linear,
            ) -> *mut root::gli::storage_linear_data_type;
        }
        extern "C" {
            #[link_name = "\u{1}data"]
            pub fn storage_linear_data1(
                this: *const root::gli::storage_linear,
            ) -> *const root::gli::storage_linear_data_type;
        }
        extern "C" {
            #[doc = " Compute the relative memory offset to access the data for a specific layer, face and level"]
            #[link_name = "\u{1}base_offset"]
            pub fn storage_linear_base_offset(
                this: *const root::gli::storage_linear,
                Layer: root::gli::storage_linear_size_type,
                Face: root::gli::storage_linear_size_type,
                Level: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}image_offset"]
            pub fn storage_linear_image_offset(
                this: *const root::gli::storage_linear,
                Coord: *const root::gli::extent1d,
                Extent: *const root::gli::extent1d,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}image_offset"]
            pub fn storage_linear_image_offset1(
                this: *const root::gli::storage_linear,
                Coord: *const root::gli::extent2d,
                Extent: *const root::gli::extent2d,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}image_offset"]
            pub fn storage_linear_image_offset2(
                this: *const root::gli::storage_linear,
                Coord: *const root::gli::extent3d,
                Extent: *const root::gli::extent3d,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[doc = " Copy a subset of a specific image of a texture"]
            #[link_name = "\u{1}copy"]
            pub fn storage_linear_copy(
                this: *mut root::gli::storage_linear,
                StorageSrc: *const root::gli::storage_linear,
                LayerSrc: usize,
                FaceSrc: usize,
                LevelSrc: usize,
                BlockIndexSrc: *const root::gli::storage_linear_extent_type,
                LayerDst: usize,
                FaceDst: usize,
                LevelDst: usize,
                BlockIndexDst: *const root::gli::storage_linear_extent_type,
                BlockCount: *const root::gli::storage_linear_extent_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}level_size"]
            pub fn storage_linear_level_size(
                this: *const root::gli::storage_linear,
                Level: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}face_size"]
            pub fn storage_linear_face_size(
                this: *const root::gli::storage_linear,
                BaseLevel: root::gli::storage_linear_size_type,
                MaxLevel: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}layer_size"]
            pub fn storage_linear_layer_size(
                this: *const root::gli::storage_linear,
                BaseFace: root::gli::storage_linear_size_type,
                MaxFace: root::gli::storage_linear_size_type,
                BaseLevel: root::gli::storage_linear_size_type,
                MaxLevel: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}storage_linear"]
            pub fn storage_linear_storage_linear(this: *mut root::gli::storage_linear);
        }
        extern "C" {
            #[link_name = "\u{1}storage_linear"]
            pub fn storage_linear_storage_linear1(
                this: *mut root::gli::storage_linear,
                Format: root::gli::storage_linear_format_type,
                Extent: *const root::gli::storage_linear_extent_type,
                Layers: root::gli::storage_linear_size_type,
                Faces: root::gli::storage_linear_size_type,
                Levels: root::gli::storage_linear_size_type,
            );
        }
        impl storage_linear {
            #[inline]
            pub unsafe fn empty(&self) -> bool {
                storage_linear_empty(self)
            }
            #[inline]
            pub unsafe fn size(&self) -> root::gli::storage_linear_size_type {
                storage_linear_size(self)
            }
            #[inline]
            pub unsafe fn layers(&self) -> root::gli::storage_linear_size_type {
                storage_linear_layers(self)
            }
            #[inline]
            pub unsafe fn levels(&self) -> root::gli::storage_linear_size_type {
                storage_linear_levels(self)
            }
            #[inline]
            pub unsafe fn faces(&self) -> root::gli::storage_linear_size_type {
                storage_linear_faces(self)
            }
            #[inline]
            pub unsafe fn block_size(&self) -> root::gli::storage_linear_size_type {
                storage_linear_block_size(self)
            }
            #[inline]
            pub unsafe fn block_extent(&self) -> root::gli::storage_linear_extent_type {
                storage_linear_block_extent(self)
            }
            #[inline]
            pub unsafe fn block_count(
                &self,
                Level: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_extent_type {
                storage_linear_block_count(self, Level)
            }
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_extent_type {
                storage_linear_extent(self, Level)
            }
            #[inline]
            pub unsafe fn data(&mut self) -> *mut root::gli::storage_linear_data_type {
                storage_linear_data(self)
            }
            #[inline]
            pub unsafe fn data1(&self) -> *const root::gli::storage_linear_data_type {
                storage_linear_data1(self)
            }
            #[inline]
            pub unsafe fn base_offset(
                &self,
                Layer: root::gli::storage_linear_size_type,
                Face: root::gli::storage_linear_size_type,
                Level: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_size_type {
                storage_linear_base_offset(self, Layer, Face, Level)
            }
            #[inline]
            pub unsafe fn image_offset(
                &self,
                Coord: *const root::gli::extent1d,
                Extent: *const root::gli::extent1d,
            ) -> root::gli::storage_linear_size_type {
                storage_linear_image_offset(self, Coord, Extent)
            }
            #[inline]
            pub unsafe fn image_offset1(
                &self,
                Coord: *const root::gli::extent2d,
                Extent: *const root::gli::extent2d,
            ) -> root::gli::storage_linear_size_type {
                storage_linear_image_offset1(self, Coord, Extent)
            }
            #[inline]
            pub unsafe fn image_offset2(
                &self,
                Coord: *const root::gli::extent3d,
                Extent: *const root::gli::extent3d,
            ) -> root::gli::storage_linear_size_type {
                storage_linear_image_offset2(self, Coord, Extent)
            }
            #[inline]
            pub unsafe fn copy(
                &mut self,
                StorageSrc: *const root::gli::storage_linear,
                LayerSrc: usize,
                FaceSrc: usize,
                LevelSrc: usize,
                BlockIndexSrc: *const root::gli::storage_linear_extent_type,
                LayerDst: usize,
                FaceDst: usize,
                LevelDst: usize,
                BlockIndexDst: *const root::gli::storage_linear_extent_type,
                BlockCount: *const root::gli::storage_linear_extent_type,
            ) {
                storage_linear_copy(
                    self,
                    StorageSrc,
                    LayerSrc,
                    FaceSrc,
                    LevelSrc,
                    BlockIndexSrc,
                    LayerDst,
                    FaceDst,
                    LevelDst,
                    BlockIndexDst,
                    BlockCount,
                )
            }
            #[inline]
            pub unsafe fn level_size(
                &self,
                Level: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_size_type {
                storage_linear_level_size(self, Level)
            }
            #[inline]
            pub unsafe fn face_size(
                &self,
                BaseLevel: root::gli::storage_linear_size_type,
                MaxLevel: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_size_type {
                storage_linear_face_size(self, BaseLevel, MaxLevel)
            }
            #[inline]
            pub unsafe fn layer_size(
                &self,
                BaseFace: root::gli::storage_linear_size_type,
                MaxFace: root::gli::storage_linear_size_type,
                BaseLevel: root::gli::storage_linear_size_type,
                MaxLevel: root::gli::storage_linear_size_type,
            ) -> root::gli::storage_linear_size_type {
                storage_linear_layer_size(self, BaseFace, MaxFace, BaseLevel, MaxLevel)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                storage_linear_storage_linear(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::storage_linear_format_type,
                Extent: *const root::gli::storage_linear_extent_type,
                Layers: root::gli::storage_linear_size_type,
                Faces: root::gli::storage_linear_size_type,
                Levels: root::gli::storage_linear_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                storage_linear_storage_linear1(
                    &mut __bindgen_tmp,
                    Format,
                    Extent,
                    Layers,
                    Faces,
                    Levels,
                );
                __bindgen_tmp
            }
        }
        #[doc = " Genetic texture class. It can support any target."]
        #[repr(C)]
        pub struct texture {
            pub Storage: [u64; 2usize],
            pub is_print_shared_storage_count: bool,
            pub Target: root::gli::texture_target_type,
            pub Format: root::gli::texture_format_type,
            pub BaseLayer: root::gli::texture_size_type,
            pub MaxLayer: root::gli::texture_size_type,
            pub BaseFace: root::gli::texture_size_type,
            pub MaxFace: root::gli::texture_size_type,
            pub BaseLevel: root::gli::texture_size_type,
            pub MaxLevel: root::gli::texture_size_type,
            pub Swizzles: root::gli::texture_swizzles_type,
            pub Cache: root::gli::texture_cache,
        }
        pub type texture_size_type = usize;
        pub use self::super::super::root::gli::format as texture_format_type;
        pub use self::super::super::root::gli::target as texture_target_type;
        pub type texture_swizzles_type = root::gli::swizzles;
        pub type texture_storage_type = root::gli::storage_linear;
        pub type texture_data_type = root::gli::storage_linear_data_type;
        pub type texture_extent_type = root::gli::storage_linear_extent_type;
        #[repr(C)]
        pub struct texture_cache {
            pub Faces: root::gli::texture_size_type,
            pub Levels: root::gli::texture_size_type,
            pub BaseAddresses: [u64; 3usize],
            pub ImageExtent: [u32; 48usize],
            pub ImageMemorySize: [u64; 16usize],
            pub GlobalMemorySize: root::gli::texture_size_type,
        }
        pub const texture_cache_ctor_DEFAULT: root::gli::texture_cache_ctor = 0;
        pub type texture_cache_ctor = u32;
        extern "C" {
            #[doc = " Return whether the texture instance is empty, no storage_type or description have been assigned to the instance."]
            #[link_name = "\u{1}empty"]
            pub fn texture_empty(this: *const root::gli::texture) -> bool;
        }
        extern "C" {
            #[doc = " Return the texture instance format"]
            #[link_name = "\u{1}format"]
            pub fn texture_format(
                this: *const root::gli::texture,
            ) -> root::gli::texture_format_type;
        }
        extern "C" {
            #[link_name = "\u{1}swizzles"]
            pub fn texture_swizzles(
                this: *const root::gli::texture,
            ) -> root::gli::texture_swizzles_type;
        }
        extern "C" {
            #[doc = " Return the base layer of the texture instance, effectively a memory offset in the actual texture storage_type to identify where to start reading the layers."]
            #[link_name = "\u{1}base_layer"]
            pub fn texture_base_layer(
                this: *const root::gli::texture,
            ) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return the max layer of the texture instance, effectively a memory offset to the beginning of the last layer in the actual texture storage_type that the texture instance can access."]
            #[link_name = "\u{1}max_layer"]
            pub fn texture_max_layer(
                this: *const root::gli::texture,
            ) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return max_layer() - base_layer() + 1"]
            #[link_name = "\u{1}layers"]
            pub fn texture_layers(this: *const root::gli::texture) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return the base face of the texture instance, effectively a memory offset in the actual texture storage_type to identify where to start reading the faces."]
            #[link_name = "\u{1}base_face"]
            pub fn texture_base_face(
                this: *const root::gli::texture,
            ) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return the max face of the texture instance, effectively a memory offset to the beginning of the last face in the actual texture storage_type that the texture instance can access."]
            #[link_name = "\u{1}max_face"]
            pub fn texture_max_face(
                this: *const root::gli::texture,
            ) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return max_face() - base_face() + 1"]
            #[link_name = "\u{1}faces"]
            pub fn texture_faces(this: *const root::gli::texture) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return the base level of the texture instance, effectively a memory offset in the actual texture storage_type to identify where to start reading the levels."]
            #[link_name = "\u{1}base_level"]
            pub fn texture_base_level(
                this: *const root::gli::texture,
            ) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return the max level of the texture instance, effectively a memory offset to the beginning of the last level in the actual texture storage_type that the texture instance can access."]
            #[link_name = "\u{1}max_level"]
            pub fn texture_max_level(
                this: *const root::gli::texture,
            ) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return max_level() - base_level() + 1."]
            #[link_name = "\u{1}levels"]
            pub fn texture_levels(this: *const root::gli::texture) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return the size of a texture instance: width, height and depth."]
            #[link_name = "\u{1}extent"]
            pub fn texture_extent(
                this: *const root::gli::texture,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture_extent_type;
        }
        extern "C" {
            #[doc = " Return the memory size of a texture instance storage_type in bytes."]
            #[link_name = "\u{1}size"]
            pub fn texture_size(this: *const root::gli::texture) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return the memory size of a specific level identified by Level."]
            #[link_name = "\u{1}size"]
            pub fn texture_size1(
                this: *const root::gli::texture,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture_size_type;
        }
        extern "C" {
            #[doc = " Return a pointer to the beginning of the texture instance data."]
            #[link_name = "\u{1}data"]
            pub fn texture_data(this: *mut root::gli::texture) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Return a pointer to the beginning of the texture instance data."]
            #[link_name = "\u{1}data"]
            pub fn texture_data1(this: *const root::gli::texture) -> *const ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Return a pointer to the beginning of the texture instance data."]
            #[link_name = "\u{1}data"]
            pub fn texture_data2(
                this: *mut root::gli::texture,
                Layer: root::gli::texture_size_type,
                Face: root::gli::texture_size_type,
                Level: root::gli::texture_size_type,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Return a pointer to the beginning of the texture instance data."]
            #[link_name = "\u{1}data"]
            pub fn texture_data3(
                this: *const root::gli::texture,
                Layer: root::gli::texture_size_type,
                Face: root::gli::texture_size_type,
                Level: root::gli::texture_size_type,
            ) -> *const ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Clear the entire texture storage_linear with zeros"]
            #[link_name = "\u{1}clear"]
            pub fn texture_clear(this: *mut root::gli::texture);
        }
        extern "C" {
            #[doc = " Copy a specific image of a texture"]
            #[link_name = "\u{1}copy"]
            pub fn texture_copy(
                this: *mut root::gli::texture,
                TextureSrc: *const root::gli::texture,
                LayerSrc: usize,
                FaceSrc: usize,
                LevelSrc: usize,
                LayerDst: usize,
                FaceDst: usize,
                LevelDst: usize,
            );
        }
        extern "C" {
            #[doc = " Copy a subset of a specific image of a texture"]
            #[link_name = "\u{1}copy"]
            pub fn texture_copy1(
                this: *mut root::gli::texture,
                TextureSrc: *const root::gli::texture,
                LayerSrc: usize,
                FaceSrc: usize,
                LevelSrc: usize,
                OffsetSrc: *const root::gli::texture_extent_type,
                LayerDst: usize,
                FaceDst: usize,
                LevelDst: usize,
                OffsetDst: *const root::gli::texture_extent_type,
                Extent: *const root::gli::texture_extent_type,
            );
        }
        extern "C" {
            #[doc = " Create an empty texture instance"]
            #[link_name = "\u{1}texture"]
            pub fn texture_texture(this: *mut root::gli::texture);
        }
        extern "C" {
            #[doc = " Create a texture object and allocate a texture storage for it"]
            #[doc = " @param Target Type/Shape of the texture storage_linear"]
            #[doc = " @param Format Texel format"]
            #[doc = " @param Extent Size of the texture: width, height and depth."]
            #[doc = " @param Layers Number of one-dimensional or two-dimensional images of identical size and format"]
            #[doc = " @param Faces 6 for cube map textures otherwise 1."]
            #[doc = " @param Levels Number of images in the texture mipmap chain."]
            #[doc = " @param Swizzles A mechanism to swizzle the components of a texture before they are applied according to the texture environment."]
            #[link_name = "\u{1}texture"]
            pub fn texture_texture1(
                this: *mut root::gli::texture,
                Target: root::gli::texture_target_type,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_extent_type,
                Layers: root::gli::texture_size_type,
                Faces: root::gli::texture_size_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture object by sharing an existing texture storage_type from another texture instance."]
            #[doc = " This texture object is effectively a texture view where the layer, the face and the level allows identifying"]
            #[doc = " a specific subset of the texture storage_linear source."]
            #[doc = " This texture object is effectively a texture view where the target and format can be reinterpreted"]
            #[doc = " with a different compatible texture target and texture format."]
            #[link_name = "\u{1}texture"]
            pub fn texture_texture2(
                this: *mut root::gli::texture,
                Texture: *const root::gli::texture,
                Target: root::gli::texture_target_type,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture object by sharing an existing texture storage_type from another texture instance."]
            #[doc = " This texture object is effectively a texture view where the target and format can be reinterpreted"]
            #[doc = " with a different compatible texture target and texture format."]
            #[link_name = "\u{1}texture"]
            pub fn texture_texture3(
                this: *mut root::gli::texture,
                Texture: *const root::gli::texture,
                Target: root::gli::texture_target_type,
                Format: root::gli::texture_format_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        impl texture {
            #[inline]
            pub unsafe fn empty(&self) -> bool {
                texture_empty(self)
            }
            #[inline]
            pub unsafe fn format(&self) -> root::gli::texture_format_type {
                texture_format(self)
            }
            #[inline]
            pub unsafe fn swizzles(&self) -> root::gli::texture_swizzles_type {
                texture_swizzles(self)
            }
            #[inline]
            pub unsafe fn base_layer(&self) -> root::gli::texture_size_type {
                texture_base_layer(self)
            }
            #[inline]
            pub unsafe fn max_layer(&self) -> root::gli::texture_size_type {
                texture_max_layer(self)
            }
            #[inline]
            pub unsafe fn layers(&self) -> root::gli::texture_size_type {
                texture_layers(self)
            }
            #[inline]
            pub unsafe fn base_face(&self) -> root::gli::texture_size_type {
                texture_base_face(self)
            }
            #[inline]
            pub unsafe fn max_face(&self) -> root::gli::texture_size_type {
                texture_max_face(self)
            }
            #[inline]
            pub unsafe fn faces(&self) -> root::gli::texture_size_type {
                texture_faces(self)
            }
            #[inline]
            pub unsafe fn base_level(&self) -> root::gli::texture_size_type {
                texture_base_level(self)
            }
            #[inline]
            pub unsafe fn max_level(&self) -> root::gli::texture_size_type {
                texture_max_level(self)
            }
            #[inline]
            pub unsafe fn levels(&self) -> root::gli::texture_size_type {
                texture_levels(self)
            }
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture_extent_type {
                texture_extent(self, Level)
            }
            #[inline]
            pub unsafe fn size(&self) -> root::gli::texture_size_type {
                texture_size(self)
            }
            #[inline]
            pub unsafe fn size1(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture_size_type {
                texture_size1(self, Level)
            }
            #[inline]
            pub unsafe fn data(&mut self) -> *mut ::std::os::raw::c_void {
                texture_data(self)
            }
            #[inline]
            pub unsafe fn data1(&self) -> *const ::std::os::raw::c_void {
                texture_data1(self)
            }
            #[inline]
            pub unsafe fn data2(
                &mut self,
                Layer: root::gli::texture_size_type,
                Face: root::gli::texture_size_type,
                Level: root::gli::texture_size_type,
            ) -> *mut ::std::os::raw::c_void {
                texture_data2(self, Layer, Face, Level)
            }
            #[inline]
            pub unsafe fn data3(
                &self,
                Layer: root::gli::texture_size_type,
                Face: root::gli::texture_size_type,
                Level: root::gli::texture_size_type,
            ) -> *const ::std::os::raw::c_void {
                texture_data3(self, Layer, Face, Level)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                texture_clear(self)
            }
            #[inline]
            pub unsafe fn copy(
                &mut self,
                TextureSrc: *const root::gli::texture,
                LayerSrc: usize,
                FaceSrc: usize,
                LevelSrc: usize,
                LayerDst: usize,
                FaceDst: usize,
                LevelDst: usize,
            ) {
                texture_copy(
                    self, TextureSrc, LayerSrc, FaceSrc, LevelSrc, LayerDst, FaceDst, LevelDst,
                )
            }
            #[inline]
            pub unsafe fn copy1(
                &mut self,
                TextureSrc: *const root::gli::texture,
                LayerSrc: usize,
                FaceSrc: usize,
                LevelSrc: usize,
                OffsetSrc: *const root::gli::texture_extent_type,
                LayerDst: usize,
                FaceDst: usize,
                LevelDst: usize,
                OffsetDst: *const root::gli::texture_extent_type,
                Extent: *const root::gli::texture_extent_type,
            ) {
                texture_copy1(
                    self, TextureSrc, LayerSrc, FaceSrc, LevelSrc, OffsetSrc, LayerDst, FaceDst,
                    LevelDst, OffsetDst, Extent,
                )
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_texture(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Target: root::gli::texture_target_type,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_extent_type,
                Layers: root::gli::texture_size_type,
                Faces: root::gli::texture_size_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_texture1(
                    &mut __bindgen_tmp,
                    Target,
                    Format,
                    Extent,
                    Layers,
                    Faces,
                    Levels,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Texture: *const root::gli::texture,
                Target: root::gli::texture_target_type,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_texture2(
                    &mut __bindgen_tmp,
                    Texture,
                    Target,
                    Format,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(
                Texture: *const root::gli::texture,
                Target: root::gli::texture_target_type,
                Format: root::gli::texture_format_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_texture3(&mut __bindgen_tmp, Texture, Target, Format, Swizzles);
                __bindgen_tmp
            }
        }
        #[doc = " Image, representation for a single texture level"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct image {
            pub is_print_shared_storage_count: bool,
            pub Storage: [u64; 2usize],
            pub Format: root::gli::image_format_type,
            pub BaseLevel: root::gli::image_size_type,
            pub Data: *mut root::gli::image_data_type,
            pub Size: root::gli::image_size_type,
        }
        pub type image_size_type = usize;
        pub use self::super::super::root::gli::format as image_format_type;
        pub type image_extent_type = root::gli::storage_linear_extent_type;
        pub type image_data_type = root::gli::storage_linear_data_type;
        extern "C" {
            #[doc = " Return whether the image instance is empty, no storage_linear or description have been assigned to the instance."]
            #[link_name = "\u{1}empty"]
            pub fn image_empty(this: *const root::gli::image) -> bool;
        }
        extern "C" {
            #[doc = " Return the image instance format."]
            #[link_name = "\u{1}format"]
            pub fn image_format(this: *const root::gli::image) -> root::gli::image_format_type;
        }
        extern "C" {
            #[doc = " Return the dimensions of an image instance: width, height and depth."]
            #[link_name = "\u{1}extent"]
            pub fn image_extent(this: *const root::gli::image) -> root::gli::image_extent_type;
        }
        extern "C" {
            #[doc = " Return the memory size of an image instance storage_linear in bytes."]
            #[link_name = "\u{1}size"]
            pub fn image_size(this: *const root::gli::image) -> root::gli::image_size_type;
        }
        extern "C" {
            #[doc = " Return a pointer to the beginning of the image instance data."]
            #[link_name = "\u{1}data"]
            pub fn image_data(this: *mut root::gli::image) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Return a pointer to the beginning of the image instance data."]
            #[link_name = "\u{1}data"]
            pub fn image_data1(this: *const root::gli::image) -> *const ::std::os::raw::c_void;
        }
        extern "C" {
            #[doc = " Clear the entire image storage_linear with zeros"]
            #[link_name = "\u{1}clear"]
            pub fn image_clear(this: *mut root::gli::image);
        }
        extern "C" {
            #[doc = " Create an empty image instance"]
            #[link_name = "\u{1}image"]
            pub fn image_image(this: *mut root::gli::image);
        }
        extern "C" {
            #[doc = " Create an image object and allocate an image storoge for it."]
            #[link_name = "\u{1}image"]
            pub fn image_image1(
                this: *mut root::gli::image,
                Format: root::gli::image_format_type,
                Extent: *const root::gli::image_extent_type,
            );
        }
        extern "C" {
            #[doc = " Create an image object by sharing an existing image storage_linear from another image instance."]
            #[doc = " This image object is effectively an image view where format can be reinterpreted"]
            #[doc = " with a different compatible image format."]
            #[doc = " For formats to be compatible, the block size of source and destination must match."]
            #[link_name = "\u{1}image"]
            pub fn image_image2(
                this: *mut root::gli::image,
                Image: *const root::gli::image,
                Format: root::gli::image_format_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}image"]
            pub fn image_image3(
                this: *mut root::gli::image,
                Texture: *const root::gli::texture,
                Format: root::gli::image_format_type,
                BaseLayer: root::gli::image_size_type,
                BaseFace: root::gli::image_size_type,
                BaseLevel: root::gli::image_size_type,
            );
        }
        impl image {
            #[inline]
            pub unsafe fn empty(&self) -> bool {
                image_empty(self)
            }
            #[inline]
            pub unsafe fn format(&self) -> root::gli::image_format_type {
                image_format(self)
            }
            #[inline]
            pub unsafe fn extent(&self) -> root::gli::image_extent_type {
                image_extent(self)
            }
            #[inline]
            pub unsafe fn size(&self) -> root::gli::image_size_type {
                image_size(self)
            }
            #[inline]
            pub unsafe fn data(&mut self) -> *mut ::std::os::raw::c_void {
                image_data(self)
            }
            #[inline]
            pub unsafe fn data1(&self) -> *const ::std::os::raw::c_void {
                image_data1(self)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                image_clear(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                image_image(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::image_format_type,
                Extent: *const root::gli::image_extent_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                image_image1(&mut __bindgen_tmp, Format, Extent);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Image: *const root::gli::image,
                Format: root::gli::image_format_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                image_image2(&mut __bindgen_tmp, Image, Format);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(
                Texture: *const root::gli::texture,
                Format: root::gli::image_format_type,
                BaseLayer: root::gli::image_size_type,
                BaseFace: root::gli::image_size_type,
                BaseLevel: root::gli::image_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                image_image3(
                    &mut __bindgen_tmp,
                    Texture,
                    Format,
                    BaseLayer,
                    BaseFace,
                    BaseLevel,
                );
                __bindgen_tmp
            }
        }
        #[doc = " 1d texture"]
        #[repr(C)]
        pub struct texture1d {
            pub _base: root::gli::texture,
        }
        pub type texture1d_extent_type = root::gli::extent1d;
        extern "C" {
            #[doc = " Return the width of a texture instance"]
            #[link_name = "\u{1}extent"]
            pub fn texture1d_extent(
                this: *const root::gli::texture1d,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture1d_extent_type;
        }
        extern "C" {
            #[doc = " Create an empty texture 1D"]
            #[link_name = "\u{1}texture1d"]
            pub fn texture1d_texture1d(this: *mut root::gli::texture1d);
        }
        extern "C" {
            #[doc = " Create a texture1d and allocate a new storage_linear"]
            #[link_name = "\u{1}texture1d"]
            pub fn texture1d_texture1d1(
                this: *mut root::gli::texture1d,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture1d_extent_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture1d and allocate a new storage_linear with a complete mipmap chain"]
            #[link_name = "\u{1}texture1d"]
            pub fn texture1d_texture1d2(
                this: *mut root::gli::texture1d,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture1d_extent_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture1d view with an existing storage_linear"]
            #[link_name = "\u{1}texture1d"]
            pub fn texture1d_texture1d3(
                this: *mut root::gli::texture1d,
                Texture: *const root::gli::texture,
            );
        }
        extern "C" {
            #[doc = " Create a texture1d view with an existing storage_linear"]
            #[link_name = "\u{1}texture1d"]
            pub fn texture1d_texture1d4(
                this: *mut root::gli::texture1d,
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture1d view, reference a subset of an existing texture1d instance"]
            #[link_name = "\u{1}texture1d"]
            pub fn texture1d_texture1d5(
                this: *mut root::gli::texture1d,
                Texture: *const root::gli::texture1d,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            );
        }
        impl texture1d {
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture1d_extent_type {
                texture1d_extent(self, Level)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_texture1d(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture1d_extent_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_texture1d1(&mut __bindgen_tmp, Format, Extent, Levels, Swizzles);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture1d_extent_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_texture1d2(&mut __bindgen_tmp, Format, Extent, Swizzles);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(Texture: *const root::gli::texture) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_texture1d3(&mut __bindgen_tmp, Texture);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_texture1d4(
                    &mut __bindgen_tmp,
                    Texture,
                    Format,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                Texture: *const root::gli::texture1d,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_texture1d5(&mut __bindgen_tmp, Texture, BaseLevel, MaxLevel);
                __bindgen_tmp
            }
        }
        #[doc = " 1d array texture"]
        #[repr(C)]
        pub struct texture1d_array {
            pub _base: root::gli::texture,
        }
        pub type texture1d_array_extent_type = root::gli::extent1d;
        extern "C" {
            #[doc = " Return the width of a texture instance"]
            #[link_name = "\u{1}extent"]
            pub fn texture1d_array_extent(
                this: *const root::gli::texture1d_array,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture1d_array_extent_type;
        }
        extern "C" {
            #[doc = " Create an empty texture 1D array"]
            #[link_name = "\u{1}texture1d_array"]
            pub fn texture1d_array_texture1d_array(this: *mut root::gli::texture1d_array);
        }
        extern "C" {
            #[doc = " Create a texture1d_array and allocate a new storage_linear"]
            #[link_name = "\u{1}texture1d_array"]
            pub fn texture1d_array_texture1d_array1(
                this: *mut root::gli::texture1d_array,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture1d_array_extent_type,
                Layers: root::gli::texture_size_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture1d_array and allocate a new storage_linear with a complete mipmap chain"]
            #[link_name = "\u{1}texture1d_array"]
            pub fn texture1d_array_texture1d_array2(
                this: *mut root::gli::texture1d_array,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture1d_array_extent_type,
                Layers: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture1d_array view with an existing storage_linear"]
            #[link_name = "\u{1}texture1d_array"]
            pub fn texture1d_array_texture1d_array3(
                this: *mut root::gli::texture1d_array,
                Texture: *const root::gli::texture,
            );
        }
        extern "C" {
            #[doc = " Create a texture1d_array view with an existing storage_linear"]
            #[link_name = "\u{1}texture1d_array"]
            pub fn texture1d_array_texture1d_array4(
                this: *mut root::gli::texture1d_array,
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture view, reference a subset of an exiting storage_linear"]
            #[link_name = "\u{1}texture1d_array"]
            pub fn texture1d_array_texture1d_array5(
                this: *mut root::gli::texture1d_array,
                Texture: *const root::gli::texture1d_array,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            );
        }
        impl texture1d_array {
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture1d_array_extent_type {
                texture1d_array_extent(self, Level)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_array_texture1d_array(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture1d_array_extent_type,
                Layers: root::gli::texture_size_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_array_texture1d_array1(
                    &mut __bindgen_tmp,
                    Format,
                    Extent,
                    Layers,
                    Levels,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture1d_array_extent_type,
                Layers: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_array_texture1d_array2(
                    &mut __bindgen_tmp,
                    Format,
                    Extent,
                    Layers,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(Texture: *const root::gli::texture) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_array_texture1d_array3(&mut __bindgen_tmp, Texture);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_array_texture1d_array4(
                    &mut __bindgen_tmp,
                    Texture,
                    Format,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                Texture: *const root::gli::texture1d_array,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture1d_array_texture1d_array5(
                    &mut __bindgen_tmp,
                    Texture,
                    BaseLayer,
                    MaxLayer,
                    BaseLevel,
                    MaxLevel,
                );
                __bindgen_tmp
            }
        }
        #[doc = " 2d texture"]
        #[repr(C)]
        pub struct texture2d {
            pub _base: root::gli::texture,
        }
        pub type texture2d_extent_type = root::gli::extent2d;
        extern "C" {
            #[doc = " Return the dimensions of a texture instance: width and height."]
            #[link_name = "\u{1}extent"]
            pub fn texture2d_extent(
                this: *const root::gli::texture2d,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture2d_extent_type;
        }
        extern "C" {
            #[doc = " Create an empty texture 2D."]
            #[link_name = "\u{1}texture2d"]
            pub fn texture2d_texture2d(this: *mut root::gli::texture2d);
        }
        extern "C" {
            #[doc = " Create a texture2d and allocate a new storage_linear."]
            #[link_name = "\u{1}texture2d"]
            pub fn texture2d_texture2d1(
                this: *mut root::gli::texture2d,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture2d_extent_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture2d and allocate a new storage_linear with a complete mipmap chain."]
            #[link_name = "\u{1}texture2d"]
            pub fn texture2d_texture2d2(
                this: *mut root::gli::texture2d,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture2d_extent_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture2d view with an existing storage_linear."]
            #[link_name = "\u{1}texture2d"]
            pub fn texture2d_texture2d3(
                this: *mut root::gli::texture2d,
                Texture: *const root::gli::texture,
            );
        }
        extern "C" {
            #[doc = " Create a texture2d view with an existing storage_linear."]
            #[link_name = "\u{1}texture2d"]
            pub fn texture2d_texture2d4(
                this: *mut root::gli::texture2d,
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture2d view, reference a subset of an existing texture2d instance."]
            #[link_name = "\u{1}texture2d"]
            pub fn texture2d_texture2d5(
                this: *mut root::gli::texture2d,
                Texture: *const root::gli::texture2d,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            );
        }
        impl texture2d {
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture2d_extent_type {
                texture2d_extent(self, Level)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_texture2d(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture2d_extent_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_texture2d1(&mut __bindgen_tmp, Format, Extent, Levels, Swizzles);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture2d_extent_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_texture2d2(&mut __bindgen_tmp, Format, Extent, Swizzles);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(Texture: *const root::gli::texture) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_texture2d3(&mut __bindgen_tmp, Texture);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_texture2d4(
                    &mut __bindgen_tmp,
                    Texture,
                    Format,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                Texture: *const root::gli::texture2d,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_texture2d5(&mut __bindgen_tmp, Texture, BaseLevel, MaxLevel);
                __bindgen_tmp
            }
        }
        #[doc = " 2d array texture"]
        #[repr(C)]
        pub struct texture2d_array {
            pub _base: root::gli::texture,
        }
        pub type texture2d_array_extent_type = root::gli::extent2d;
        extern "C" {
            #[doc = " Return the dimensions of a texture instance: width and height"]
            #[link_name = "\u{1}extent"]
            pub fn texture2d_array_extent(
                this: *const root::gli::texture2d_array,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture2d_array_extent_type;
        }
        extern "C" {
            #[doc = " Create an empty texture 2D array"]
            #[link_name = "\u{1}texture2d_array"]
            pub fn texture2d_array_texture2d_array(this: *mut root::gli::texture2d_array);
        }
        extern "C" {
            #[doc = " Create a texture2d_array and allocate a new storage_linear"]
            #[link_name = "\u{1}texture2d_array"]
            pub fn texture2d_array_texture2d_array1(
                this: *mut root::gli::texture2d_array,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture2d_array_extent_type,
                Layers: root::gli::texture_size_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture2d_array and allocate a new storage_linear with a complete mipmap chain"]
            #[link_name = "\u{1}texture2d_array"]
            pub fn texture2d_array_texture2d_array2(
                this: *mut root::gli::texture2d_array,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture2d_array_extent_type,
                Layers: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture2d_array view with an existing storage_linear"]
            #[link_name = "\u{1}texture2d_array"]
            pub fn texture2d_array_texture2d_array3(
                this: *mut root::gli::texture2d_array,
                Texture: *const root::gli::texture,
            );
        }
        extern "C" {
            #[doc = " Create a texture2d_array view with an existing storage_linear"]
            #[link_name = "\u{1}texture2d_array"]
            pub fn texture2d_array_texture2d_array4(
                this: *mut root::gli::texture2d_array,
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture view, reference a subset of an exiting texture2d_array instance"]
            #[link_name = "\u{1}texture2d_array"]
            pub fn texture2d_array_texture2d_array5(
                this: *mut root::gli::texture2d_array,
                Texture: *const root::gli::texture2d_array,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            );
        }
        impl texture2d_array {
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture2d_array_extent_type {
                texture2d_array_extent(self, Level)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_array_texture2d_array(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture2d_array_extent_type,
                Layers: root::gli::texture_size_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_array_texture2d_array1(
                    &mut __bindgen_tmp,
                    Format,
                    Extent,
                    Layers,
                    Levels,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture2d_array_extent_type,
                Layers: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_array_texture2d_array2(
                    &mut __bindgen_tmp,
                    Format,
                    Extent,
                    Layers,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(Texture: *const root::gli::texture) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_array_texture2d_array3(&mut __bindgen_tmp, Texture);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_array_texture2d_array4(
                    &mut __bindgen_tmp,
                    Texture,
                    Format,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                Texture: *const root::gli::texture2d_array,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture2d_array_texture2d_array5(
                    &mut __bindgen_tmp,
                    Texture,
                    BaseLayer,
                    MaxLayer,
                    BaseLevel,
                    MaxLevel,
                );
                __bindgen_tmp
            }
        }
        #[doc = " 3d texture"]
        #[repr(C)]
        pub struct texture3d {
            pub _base: root::gli::texture,
        }
        pub type texture3d_extent_type = root::gli::extent3d;
        extern "C" {
            #[doc = " Return the dimensions of a texture instance: width, height and depth"]
            #[link_name = "\u{1}extent"]
            pub fn texture3d_extent(
                this: *const root::gli::texture3d,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture3d_extent_type;
        }
        extern "C" {
            #[doc = " Create an empty texture 3D"]
            #[link_name = "\u{1}texture3d"]
            pub fn texture3d_texture3d(this: *mut root::gli::texture3d);
        }
        extern "C" {
            #[doc = " Create a texture3d and allocate a new storage_linear"]
            #[link_name = "\u{1}texture3d"]
            pub fn texture3d_texture3d1(
                this: *mut root::gli::texture3d,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture3d_extent_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture3d and allocate a new storage_linear with a complete mipmap chain"]
            #[link_name = "\u{1}texture3d"]
            pub fn texture3d_texture3d2(
                this: *mut root::gli::texture3d,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture3d_extent_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture3d view with an existing storage_linear"]
            #[link_name = "\u{1}texture3d"]
            pub fn texture3d_texture3d3(
                this: *mut root::gli::texture3d,
                Texture: *const root::gli::texture,
            );
        }
        extern "C" {
            #[doc = " Create a texture3d view with an existing storage_linear"]
            #[link_name = "\u{1}texture3d"]
            pub fn texture3d_texture3d4(
                this: *mut root::gli::texture3d,
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture3d view, reference a subset of an existing texture3d instance"]
            #[link_name = "\u{1}texture3d"]
            pub fn texture3d_texture3d5(
                this: *mut root::gli::texture3d,
                Texture: *const root::gli::texture3d,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            );
        }
        impl texture3d {
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture3d_extent_type {
                texture3d_extent(self, Level)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture3d_texture3d(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture3d_extent_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture3d_texture3d1(&mut __bindgen_tmp, Format, Extent, Levels, Swizzles);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture3d_extent_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture3d_texture3d2(&mut __bindgen_tmp, Format, Extent, Swizzles);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(Texture: *const root::gli::texture) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture3d_texture3d3(&mut __bindgen_tmp, Texture);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture3d_texture3d4(
                    &mut __bindgen_tmp,
                    Texture,
                    Format,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                Texture: *const root::gli::texture3d,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture3d_texture3d5(&mut __bindgen_tmp, Texture, BaseLevel, MaxLevel);
                __bindgen_tmp
            }
        }
        #[doc = " Cube map texture"]
        #[repr(C)]
        pub struct texture_cube {
            pub _base: root::gli::texture,
        }
        pub type texture_cube_extent_type = root::gli::extent2d;
        extern "C" {
            #[doc = " Return the dimensions of a texture instance: width and height where both should be equal."]
            #[link_name = "\u{1}extent"]
            pub fn texture_cube_extent(
                this: *const root::gli::texture_cube,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture_cube_extent_type;
        }
        extern "C" {
            #[doc = " Create an empty texture cube"]
            #[link_name = "\u{1}texture_cube"]
            pub fn texture_cube_texture_cube(this: *mut root::gli::texture_cube);
        }
        extern "C" {
            #[doc = " Create a texture_cube and allocate a new storage_linear"]
            #[link_name = "\u{1}texture_cube"]
            pub fn texture_cube_texture_cube1(
                this: *mut root::gli::texture_cube,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_cube_extent_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture_cube and allocate a new storage_linear with a complete mipmap chain"]
            #[link_name = "\u{1}texture_cube"]
            pub fn texture_cube_texture_cube2(
                this: *mut root::gli::texture_cube,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_cube_extent_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture_cube view with an existing storage_linear"]
            #[link_name = "\u{1}texture_cube"]
            pub fn texture_cube_texture_cube3(
                this: *mut root::gli::texture_cube,
                Texture: *const root::gli::texture,
            );
        }
        extern "C" {
            #[doc = " Create a texture_cube view with an existing storage_linear"]
            #[link_name = "\u{1}texture_cube"]
            pub fn texture_cube_texture_cube4(
                this: *mut root::gli::texture_cube,
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture_cube view, reference a subset of an existing texture_cube instance"]
            #[link_name = "\u{1}texture_cube"]
            pub fn texture_cube_texture_cube5(
                this: *mut root::gli::texture_cube,
                Texture: *const root::gli::texture_cube,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            );
        }
        impl texture_cube {
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture_cube_extent_type {
                texture_cube_extent(self, Level)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_texture_cube(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_cube_extent_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_texture_cube1(&mut __bindgen_tmp, Format, Extent, Levels, Swizzles);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_cube_extent_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_texture_cube2(&mut __bindgen_tmp, Format, Extent, Swizzles);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(Texture: *const root::gli::texture) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_texture_cube3(&mut __bindgen_tmp, Texture);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_texture_cube4(
                    &mut __bindgen_tmp,
                    Texture,
                    Format,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                Texture: *const root::gli::texture_cube,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_texture_cube5(
                    &mut __bindgen_tmp,
                    Texture,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                );
                __bindgen_tmp
            }
        }
        #[doc = " Cube map array texture"]
        #[repr(C)]
        pub struct texture_cube_array {
            pub _base: root::gli::texture,
        }
        pub type texture_cube_array_extent_type = root::gli::extent2d;
        extern "C" {
            #[doc = " Return the dimensions of a texture instance: width and height where both should be equal."]
            #[link_name = "\u{1}extent"]
            pub fn texture_cube_array_extent(
                this: *const root::gli::texture_cube_array,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture_cube_array_extent_type;
        }
        extern "C" {
            #[doc = " Create an empty texture cube array"]
            #[link_name = "\u{1}texture_cube_array"]
            pub fn texture_cube_array_texture_cube_array(this: *mut root::gli::texture_cube_array);
        }
        extern "C" {
            #[doc = " Create a texture_cube_array and allocate a new storage_linear"]
            #[link_name = "\u{1}texture_cube_array"]
            pub fn texture_cube_array_texture_cube_array1(
                this: *mut root::gli::texture_cube_array,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_cube_array_extent_type,
                Layers: root::gli::texture_size_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture_cube_array and allocate a new storage_linear with a complete mipmap chain"]
            #[link_name = "\u{1}texture_cube_array"]
            pub fn texture_cube_array_texture_cube_array2(
                this: *mut root::gli::texture_cube_array,
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_cube_array_extent_type,
                Layers: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture_cube_array view with an existing storage_linear"]
            #[link_name = "\u{1}texture_cube_array"]
            pub fn texture_cube_array_texture_cube_array3(
                this: *mut root::gli::texture_cube_array,
                Texture: *const root::gli::texture,
            );
        }
        extern "C" {
            #[doc = " Reference a subset of an exiting storage_linear constructor"]
            #[link_name = "\u{1}texture_cube_array"]
            pub fn texture_cube_array_texture_cube_array4(
                this: *mut root::gli::texture_cube_array,
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            );
        }
        extern "C" {
            #[doc = " Create a texture view, reference a subset of an exiting texture_cube_array instance"]
            #[link_name = "\u{1}texture_cube_array"]
            pub fn texture_cube_array_texture_cube_array5(
                this: *mut root::gli::texture_cube_array,
                Texture: *const root::gli::texture_cube_array,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            );
        }
        impl texture_cube_array {
            #[inline]
            pub unsafe fn extent(
                &self,
                Level: root::gli::texture_size_type,
            ) -> root::gli::texture_cube_array_extent_type {
                texture_cube_array_extent(self, Level)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_array_texture_cube_array(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_cube_array_extent_type,
                Layers: root::gli::texture_size_type,
                Levels: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_array_texture_cube_array1(
                    &mut __bindgen_tmp,
                    Format,
                    Extent,
                    Layers,
                    Levels,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                Format: root::gli::texture_format_type,
                Extent: *const root::gli::texture_cube_array_extent_type,
                Layers: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_array_texture_cube_array2(
                    &mut __bindgen_tmp,
                    Format,
                    Extent,
                    Layers,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(Texture: *const root::gli::texture) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_array_texture_cube_array3(&mut __bindgen_tmp, Texture);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(
                Texture: *const root::gli::texture,
                Format: root::gli::texture_format_type,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
                Swizzles: *const root::gli::texture_swizzles_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_array_texture_cube_array4(
                    &mut __bindgen_tmp,
                    Texture,
                    Format,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                    Swizzles,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new5(
                Texture: *const root::gli::texture_cube_array,
                BaseLayer: root::gli::texture_size_type,
                MaxLayer: root::gli::texture_size_type,
                BaseFace: root::gli::texture_size_type,
                MaxFace: root::gli::texture_size_type,
                BaseLevel: root::gli::texture_size_type,
                MaxLevel: root::gli::texture_size_type,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                texture_cube_array_texture_cube_array5(
                    &mut __bindgen_tmp,
                    Texture,
                    BaseLayer,
                    MaxLayer,
                    BaseFace,
                    MaxFace,
                    BaseLevel,
                    MaxLevel,
                );
                __bindgen_tmp
            }
        }
        extern "C" {
            #[doc = " Evaluate whether a target and format combinaison is only supported by the DDS container through GLI DDS extension."]
            pub fn is_dds_ext(Target: root::gli::target, Format: root::gli::format) -> bool;
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = u64;
        pub type allocator_difference_type = u64;
        pub type allocator_pointer = u8;
        pub type allocator_const_pointer = u8;
        pub type allocator_reference = u8;
        pub type allocator_const_reference = u8;
        pub type allocator_value_type = u8;
        pub type allocator_propagate_on_container_move_assignment = u8;
        pub type allocator_is_always_equal = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        pub type shared_ptr_element_type = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct shared_ptr___nat {
            pub _address: u8,
        }
        pub type shared_ptr___shared_ptr_default_allocator_type = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector___base = u8;
        pub type vector___default_allocator_type = u8;
        pub type vector___self = u8;
        pub type vector_value_type = u8;
        pub type vector_allocator_type = u8;
        pub type vector___alloc_traits = u8;
        pub type vector_reference = u8;
        pub type vector_const_reference = u8;
        pub type vector_size_type = u8;
        pub type vector_difference_type = u8;
        pub type vector_pointer = u8;
        pub type vector_const_pointer = u8;
        pub type vector_iterator = u8;
        pub type vector_const_iterator = u8;
        pub type vector_reverse_iterator = u8;
        pub type vector_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector___RAII_IncreaseAnnotator {
            pub _address: u8,
        }
        pub type array___self = u8;
        pub type array_value_type = u8;
        pub type array_reference = u8;
        pub type array_const_reference = u8;
        pub type array_iterator = u8;
        pub type array_const_iterator = u8;
        pub type array_pointer = u8;
        pub type array_const_pointer = u8;
        pub type array_size_type = u64;
        pub type array_difference_type = u64;
        pub type array_reverse_iterator = u8;
        pub type array_const_reverse_iterator = u8;
    }
    pub mod glm {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[doc = " 8 bit unsigned integer type."]
        pub type uint8 = u8;
        #[doc = " 1 component vector of signed integer numbers."]
        pub type ivec1 = u32;
        #[doc = " 2 components vector of signed integer numbers."]
        #[doc = ""]
        #[doc = " @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>"]
        pub type ivec2 = [u32; 2usize];
        #[doc = " 3 components vector of signed integer numbers."]
        #[doc = ""]
        #[doc = " @see <a href=\"http://www.opengl.org/registry/doc/GLSLangSpec.4.20.8.pdf\">GLSL 4.20.8 specification, section 4.1.5 Vectors</a>"]
        pub type ivec3 = [u32; 3usize];
    }
    pub mod bindings {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod Texture {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn texture_empty(tex: *const root::gli::texture) -> bool;
            }
            extern "C" {
                pub fn texture_format(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_format_type;
            }
            extern "C" {
                pub fn texture_target(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_target_type;
            }
            extern "C" {
                pub fn texture_swizzles(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_swizzles_type;
            }
            extern "C" {
                pub fn texture_base_layer(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_max_layer(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_layers(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_base_face(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_max_face(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_faces(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_base_level(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_max_level(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_levels(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_extent(
                    tex: *const root::gli::texture,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture_extent_type;
            }
            extern "C" {
                pub fn texture_size(tex: *const root::gli::texture)
                    -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_size_level(
                    tex: *const root::gli::texture,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture_size_type;
            }
            extern "C" {
                pub fn texture_data(
                    tex: *const root::gli::texture,
                ) -> *const ::std::os::raw::c_void;
            }
            extern "C" {
                pub fn texture_data_mut(
                    tex: *mut root::gli::texture,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                pub fn texture_data_detail(
                    tex: *const root::gli::texture,
                    layer: root::gli::texture_size_type,
                    face: root::gli::texture_size_type,
                    level: root::gli::texture_size_type,
                ) -> *const ::std::os::raw::c_void;
            }
            extern "C" {
                pub fn texture_data_detail_mut(
                    tex: *mut root::gli::texture,
                    layer: root::gli::texture_size_type,
                    face: root::gli::texture_size_type,
                    level: root::gli::texture_size_type,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                pub fn texture_clear(tex: *mut root::gli::texture);
            }
            extern "C" {
                pub fn texture_copy(
                    tex: *mut root::gli::texture,
                    src: *const root::gli::texture,
                    src_layer: usize,
                    src_face: usize,
                    src_level: usize,
                    dst_layer: usize,
                    dst_face: usize,
                    dst_level: usize,
                );
            }
            extern "C" {
                pub fn texture_copy_subset(
                    tex: *mut root::gli::texture,
                    src: *const root::gli::texture,
                    src_layer: usize,
                    src_face: usize,
                    src_level: usize,
                    src_offset: *const root::gli::texture_extent_type,
                    dst_layer: usize,
                    dst_face: usize,
                    dst_level: usize,
                    dst_offset: *const root::gli::texture_extent_type,
                    extent: *const root::gli::texture_extent_type,
                );
            }
            extern "C" {
                #[doc = " Manually Call destructor for texture object. Helper function used in FFI."]
                pub fn destroy_texture(tex: *mut root::gli::texture);
            }
            extern "C" {
                pub fn get_texture_shared_storage_count(
                    tex: *const root::gli::texture,
                ) -> ::std::os::raw::c_int;
            }
        }
        pub mod Image {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn image_new_empty() -> root::gli::image;
            }
            extern "C" {
                pub fn image_new_(
                    format: root::gli::image_format_type,
                    extent: root::gli::image_extent_type,
                ) -> root::gli::image;
            }
            extern "C" {
                pub fn image_share_from(
                    img: *const root::gli::image,
                    format: root::gli::image_format_type,
                ) -> root::gli::image;
            }
            extern "C" {
                pub fn image_share_from_texture(
                    tex: *const root::gli::texture,
                    format: root::gli::image_format_type,
                    base_layer: root::gli::image_size_type,
                    base_face: root::gli::image_size_type,
                    base_level: root::gli::image_size_type,
                ) -> root::gli::image;
            }
            extern "C" {
                pub fn image_empty(img: *const root::gli::image) -> bool;
            }
            extern "C" {
                pub fn image_format(img: *const root::gli::image) -> root::gli::image_format_type;
            }
            extern "C" {
                pub fn image_extent(img: *const root::gli::image) -> root::gli::image_extent_type;
            }
            extern "C" {
                pub fn image_size(img: *const root::gli::image) -> root::gli::image_size_type;
            }
            extern "C" {
                pub fn image_data_mut(img: *mut root::gli::image) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                pub fn image_data(img: *const root::gli::image) -> *const ::std::os::raw::c_void;
            }
            extern "C" {
                pub fn image_clear(img: *mut root::gli::image);
            }
            extern "C" {
                #[doc = " Manually Call destructor for image object. Helper function used in FFI."]
                pub fn destroy_image(img: *mut root::gli::image);
            }
            extern "C" {
                pub fn get_image_shared_storage_count(
                    img: *const root::gli::image,
                ) -> ::std::os::raw::c_int;
            }
        }
        pub mod Texture1D {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn tex1d_new_empty() -> root::gli::texture1d;
            }
            extern "C" {
                pub fn tex1d_new_(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture1d_extent_type,
                    levels: root::gli::texture_size_type,
                ) -> root::gli::texture1d;
            }
            extern "C" {
                pub fn tex1d_new_with_mipmap_chain(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture1d_extent_type,
                ) -> root::gli::texture1d;
            }
            extern "C" {
                pub fn tex1d_share_from(tex: *const root::gli::texture) -> root::gli::texture1d;
            }
            extern "C" {
                pub fn tex1d_share_from_detail(
                    tex: *const root::gli::texture,
                    format: root::gli::texture_format_type,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture1d;
            }
            extern "C" {
                pub fn tex1d_share_from_subset(
                    tex: *const root::gli::texture1d,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture1d;
            }
            extern "C" {
                pub fn tex1d_extent(
                    tex: *const root::gli::texture1d,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture1d_extent_type;
            }
        }
        pub mod Texture1DArray {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn tex1darray_new_empty() -> root::gli::texture1d_array;
            }
            extern "C" {
                pub fn tex1darray_new_(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture1d_array_extent_type,
                    layers: root::gli::texture_size_type,
                    levels: root::gli::texture_size_type,
                ) -> root::gli::texture1d_array;
            }
            extern "C" {
                pub fn tex1darray_new_with_mipmap_chain(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture1d_array_extent_type,
                    layers: root::gli::texture_size_type,
                ) -> root::gli::texture1d_array;
            }
            extern "C" {
                pub fn tex1darray_share_from(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture1d_array;
            }
            extern "C" {
                pub fn tex1darray_share_from_detail(
                    tex: *const root::gli::texture,
                    format: root::gli::texture_format_type,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture1d_array;
            }
            extern "C" {
                pub fn tex1darray_share_from_subset(
                    tex: *const root::gli::texture1d_array,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture1d_array;
            }
            extern "C" {
                pub fn tex1darray_extent(
                    tex: *const root::gli::texture1d_array,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture1d_array_extent_type;
            }
        }
        pub mod Texture2D {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn tex2d_new_empty() -> root::gli::texture2d;
            }
            extern "C" {
                pub fn tex2d_new_(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture2d_extent_type,
                    levels: root::gli::texture_size_type,
                ) -> root::gli::texture2d;
            }
            extern "C" {
                pub fn tex2d_new_with_mipmap_chain(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture2d_extent_type,
                ) -> root::gli::texture2d;
            }
            extern "C" {
                pub fn tex2d_share_from(tex: *const root::gli::texture) -> root::gli::texture2d;
            }
            extern "C" {
                pub fn tex2d_share_from_detail(
                    tex: *const root::gli::texture,
                    format: root::gli::texture_format_type,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture2d;
            }
            extern "C" {
                pub fn tex2d_share_from_subset(
                    tex: *const root::gli::texture2d,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture2d;
            }
            extern "C" {
                pub fn tex2d_extent(
                    tex: *const root::gli::texture2d,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture2d_extent_type;
            }
        }
        pub mod Texture2DArray {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn tex2darray_new_empty() -> root::gli::texture2d_array;
            }
            extern "C" {
                pub fn tex2darray_new_(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture2d_array_extent_type,
                    layers: root::gli::texture_size_type,
                    levels: root::gli::texture_size_type,
                ) -> root::gli::texture2d_array;
            }
            extern "C" {
                pub fn tex2darray_new_with_mipmap_chain(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture2d_array_extent_type,
                    layers: root::gli::texture_size_type,
                ) -> root::gli::texture2d_array;
            }
            extern "C" {
                pub fn tex2darray_share_from(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture2d_array;
            }
            extern "C" {
                pub fn tex2darray_share_from_detail(
                    tex: *const root::gli::texture,
                    format: root::gli::texture_format_type,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture2d_array;
            }
            extern "C" {
                pub fn tex2darray_share_from_subset(
                    tex: *const root::gli::texture2d_array,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture2d_array;
            }
            extern "C" {
                pub fn tex2darray_extent(
                    tex: *const root::gli::texture2d_array,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture2d_array_extent_type;
            }
        }
        pub mod Texture3D {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn tex3d_new_empty() -> root::gli::texture3d;
            }
            extern "C" {
                pub fn tex3d_new_(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture3d_extent_type,
                    levels: root::gli::texture_size_type,
                ) -> root::gli::texture3d;
            }
            extern "C" {
                pub fn tex3d_new_with_mipmap_chain(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture3d_extent_type,
                ) -> root::gli::texture3d;
            }
            extern "C" {
                pub fn tex3d_share_from(tex: *const root::gli::texture) -> root::gli::texture3d;
            }
            extern "C" {
                pub fn tex3d_share_from_detail(
                    tex: *const root::gli::texture,
                    format: root::gli::texture_format_type,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture3d;
            }
            extern "C" {
                pub fn tex3d_share_from_subset(
                    tex: *const root::gli::texture3d,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture3d;
            }
            extern "C" {
                pub fn tex3d_extent(
                    tex: *const root::gli::texture3d,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture3d_extent_type;
            }
        }
        pub mod TextureCube {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn texcube_new_empty() -> root::gli::texture_cube;
            }
            extern "C" {
                pub fn texcube_new_(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture_cube_extent_type,
                    levels: root::gli::texture_size_type,
                ) -> root::gli::texture_cube;
            }
            extern "C" {
                pub fn texcube_new_with_mipmap_chain(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture_cube_extent_type,
                ) -> root::gli::texture_cube;
            }
            extern "C" {
                pub fn texcube_share_from(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_cube;
            }
            extern "C" {
                pub fn texcube_share_from_detail(
                    tex: *const root::gli::texture,
                    format: root::gli::texture_format_type,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture_cube;
            }
            extern "C" {
                pub fn texcube_share_from_subset(
                    tex: *const root::gli::texture_cube,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture_cube;
            }
            extern "C" {
                pub fn texcube_extent(
                    tex: *const root::gli::texture_cube,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture_cube_extent_type;
            }
        }
        pub mod TextureCubeArray {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn texcubearray_new_empty() -> root::gli::texture_cube_array;
            }
            extern "C" {
                pub fn texcubearray_new_(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture_cube_array_extent_type,
                    layers: root::gli::texture_size_type,
                    levels: root::gli::texture_size_type,
                ) -> root::gli::texture_cube_array;
            }
            extern "C" {
                pub fn texcubearray_new_with_mipmap_chain(
                    format: root::gli::texture_format_type,
                    extent: root::gli::texture_cube_array_extent_type,
                    layers: root::gli::texture_size_type,
                ) -> root::gli::texture_cube_array;
            }
            extern "C" {
                pub fn texcubearray_share_from(
                    tex: *const root::gli::texture,
                ) -> root::gli::texture_cube_array;
            }
            extern "C" {
                pub fn texcubearray_share_from_detail(
                    tex: *const root::gli::texture,
                    format: root::gli::texture_format_type,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture_cube_array;
            }
            extern "C" {
                pub fn texcubearray_share_from_subset(
                    tex: *const root::gli::texture_cube_array,
                    base_layer: root::gli::texture_size_type,
                    max_layer: root::gli::texture_size_type,
                    base_face: root::gli::texture_size_type,
                    max_face: root::gli::texture_size_type,
                    base_level: root::gli::texture_size_type,
                    max_level: root::gli::texture_size_type,
                ) -> root::gli::texture_cube_array;
            }
            extern "C" {
                pub fn texcubearray_extent(
                    tex: *const root::gli::texture_cube_array,
                    level: root::gli::texture_size_type,
                ) -> root::gli::texture_cube_array_extent_type;
            }
        }
        pub mod Load {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn load_load(
                    Data: *const ::std::os::raw::c_char,
                    Size: usize,
                ) -> root::gli::texture;
            }
            extern "C" {
                pub fn load_load_dds(
                    Data: *const ::std::os::raw::c_char,
                    Size: usize,
                ) -> root::gli::texture;
            }
            extern "C" {
                pub fn load_load_kmg(
                    Data: *const ::std::os::raw::c_char,
                    Size: usize,
                ) -> root::gli::texture;
            }
            extern "C" {
                pub fn load_load_ktx(
                    Data: *const ::std::os::raw::c_char,
                    Size: usize,
                ) -> root::gli::texture;
            }
        }
        pub mod Save {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                pub fn save_save_dds(
                    Texture: *const root::gli::texture,
                    Path: *const ::std::os::raw::c_char,
                ) -> bool;
            }
            extern "C" {
                pub fn save_save_kmg(
                    Texture: *const root::gli::texture,
                    Path: *const ::std::os::raw::c_char,
                ) -> bool;
            }
            extern "C" {
                pub fn save_save_ktx(
                    Texture: *const root::gli::texture,
                    Path: *const ::std::os::raw::c_char,
                ) -> bool;
            }
        }
    }
}
